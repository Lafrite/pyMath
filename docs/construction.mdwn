# Explication sur la logique des classes

## Les types
Ce sont les objects que l'on s'autorise à manipuler dans les expressions. 
Ces objets doivent pouvoir être afficher en *txt* ou en *tex* avec les méthodes
    * *__txt__*: affichage en mode text
    * *__tex__*: affichage pour une compilation latex

### Operator
Cette classe regroupe les operateurs. Que l'on s'autorise à utiliser. On y accède à partir de deux caractérisiques le symbole et l'arité.

Liste des attributs importants:
    * arity: nombre d'opérande accepté
    * priority: où se place l'opérateur dans la règles des priorités parmis les autres opérateurs
    * isOperator: permet de vérifier que c'est bien un opérateur
Liste des méthodes importantes:
    * *__call__*: Permet d'effectuer le calcul sur deux opérandes
    * *__txt__*: affichage en mode text
    * *__tex__*: affichage pour une compilation latex

### Number
Tous les types de "nombres" que l'on va vouloir manipuler. On va essayer de rester le plus proche de la construction mathématiques de ces objets. 

Par défaut, on travaillera avec des anneaux ce qui permettra de construire ensuite le corps des fractions et l'anneau des polynomes (quitte à quotienter) associé.

Pour définir ces anneaux, il faudra contre avoir les méthodes suivantes:
    * *__add__*
    * *__radd__*
    ...

#### Fractions

#### Polynomes

#### Quotient de polynomes (racines)

## Expression

## Render

## Simplify-simplified / compute-child

Dans cette partie, on va expliquer le fonctionnement des mécanismes de simplification des expressions/objets mathématiques.

La simplification des expressions se fait avec les deux méthodes suivantes:

* *simplify()* pour:
    * un polynôme permet d'accéder à la forme canonique d'un polynôme
    * une fraction permet d'avoir la fraction irréductible associée
    * une expression permet de faire tous les calculs possibles de cette expression (à la fin il ne doit y avoir qu'un élément de la liste de tokens)
* *compute_exp()* pour:
    * un polynôme ou une fraction fait la même chose que $simplify$.
    * une expression fait tous les calculs élémentaires de cette expression.

Ces deux méthodes fonctionnent ensuite sur le même principe. Elles vont faire le calcul qui leurs est attribuée en enregistrant les étapes dans *steps* puis elles retourneront l'objet de fin de calcul à qui sera assigné les *steps* (ce qui nécessitera par exemple de détourner la classe *int*).

### Tentative d'explications
C'est ce que je voudrai donc le render ne sera peut être pas exactement le même.

    >>> P = Polynom([0,1,2])
    >>> Q = Polynom([1,1,1])
    >>> R = P+Q
    >>> print(R)
    3x^2 + 2x + 1
    >>> for i in explain(R):
    ...     print(i)
    2x^2 + x + x^2 + x + 1
    (2 + 1)x^2 + (1+1)x + 1
    3x^3 + 2x + 1

    >>> P = Polynom([[1,2], [3,4]])
    >>> Q = P.simplify()
    >>> print(Q)
    7x + 3
    >>> for i in explain(Q):
    ...     print(i)
    3x + 4x + 1 + 2
    (3+4)x + (1+2)
    7x + 3
    


